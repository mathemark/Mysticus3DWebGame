{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from '../../../build/three.module.js';\nvar BufferGeometryUtils = {\n  computeTangents: function computeTangents(geometry) {\n    geometry.computeTangents();\n    console.warn('THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.');\n  },\n  /**\n   * @param  {Array<BufferGeometry>} geometries\n   * @param  {Boolean} useGroups\n   * @return {BufferGeometry}\n   */\n  mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\n    var isIndexed = geometries[0].index !== null;\n    var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    var attributes = {};\n    var morphAttributes = {};\n    var morphTargetsRelative = geometries[0].morphTargetsRelative;\n    var mergedGeometry = new BufferGeometry();\n    var offset = 0;\n    for (var i = 0; i < geometries.length; ++i) {\n      var geometry = geometries[i];\n      var attributesCount = 0;\n\n      // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      // gather attributes, exit early if they're different\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n          return null;\n        }\n        if (attributes[name] === undefined) attributes[name] = [];\n        attributes[name].push(geometry.attributes[name]);\n        attributesCount++;\n      }\n\n      // ensure geometries have the same number of attributes\n\n      if (attributesCount !== attributesUsed.size) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n        return null;\n      }\n\n      // gather morph attributes, exit early if they're different\n\n      if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n        return null;\n      }\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n          return null;\n        }\n        if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n        morphAttributes[name].push(geometry.morphAttributes[name]);\n      }\n\n      // gather .userData\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n      mergedGeometry.userData.mergedUserData.push(geometry.userData);\n      if (useGroups) {\n        var count;\n        if (isIndexed) {\n          count = geometry.index.count;\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count;\n        } else {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n          return null;\n        }\n        mergedGeometry.addGroup(offset, count, i);\n        offset += count;\n      }\n    }\n\n    // merge indices\n\n    if (isIndexed) {\n      var indexOffset = 0;\n      var mergedIndex = [];\n      for (var i = 0; i < geometries.length; ++i) {\n        var index = geometries[i].index;\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset);\n        }\n        indexOffset += geometries[i].attributes.position.count;\n      }\n      mergedGeometry.setIndex(mergedIndex);\n    }\n\n    // merge attributes\n\n    for (var name in attributes) {\n      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n      if (!mergedAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n        return null;\n      }\n      mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n\n    // merge morph attributes\n\n    for (var name in morphAttributes) {\n      var numMorphTargets = morphAttributes[name][0].length;\n      if (numMorphTargets === 0) break;\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n      mergedGeometry.morphAttributes[name] = [];\n      for (var i = 0; i < numMorphTargets; ++i) {\n        var morphAttributesToMerge = [];\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i]);\n        }\n        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n        if (!mergedMorphAttribute) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n          return null;\n        }\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n      }\n    }\n    return mergedGeometry;\n  },\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {BufferAttribute}\n   */\n  mergeBufferAttributes: function mergeBufferAttributes(attributes) {\n    var TypedArray;\n    var itemSize;\n    var normalized;\n    var arrayLength = 0;\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n      if (attribute.isInterleavedBufferAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n        return null;\n      }\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n        return null;\n      }\n      if (itemSize === undefined) itemSize = attribute.itemSize;\n      if (itemSize !== attribute.itemSize) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n        return null;\n      }\n      if (normalized === undefined) normalized = attribute.normalized;\n      if (normalized !== attribute.normalized) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n        return null;\n      }\n      arrayLength += attribute.array.length;\n    }\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset);\n      offset += attributes[i].array.length;\n    }\n    return new BufferAttribute(array, itemSize, normalized);\n  },\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {Array<InterleavedBufferAttribute>}\n   */\n  interleaveAttributes: function interleaveAttributes(attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    var TypedArray;\n    var arrayLength = 0;\n    var stride = 0;\n\n    // calculate the the length and type of the interleavedBuffer\n    for (var i = 0, l = attributes.length; i < l; ++i) {\n      var attribute = attributes[i];\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('AttributeBuffers of different types cannot be interleaved');\n        return null;\n      }\n      arrayLength += attribute.array.length;\n      stride += attribute.itemSize;\n    }\n\n    // Create the set of buffer attributes\n    var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n    var offset = 0;\n    var res = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n    var setters = ['setX', 'setY', 'setZ', 'setW'];\n    for (var j = 0, l = attributes.length; j < l; j++) {\n      var attribute = attributes[j];\n      var itemSize = attribute.itemSize;\n      var count = attribute.count;\n      var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n      res.push(iba);\n      offset += itemSize;\n\n      // Move the data for each attribute into the new interleavedBuffer\n      // at the appropriate offset\n      for (var c = 0; c < count; c++) {\n        for (var k = 0; k < itemSize; k++) {\n          iba[setters[k]](c, attribute[getters[k]](c));\n        }\n      }\n    }\n    return res;\n  },\n  /**\n   * @param {Array<BufferGeometry>} geometry\n   * @return {number}\n   */\n  estimateBytesUsed: function estimateBytesUsed(geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    var mem = 0;\n    for (var name in geometry.attributes) {\n      var attr = geometry.getAttribute(name);\n      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    var indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n  },\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {BufferGeometry>}\n   */\n  mergeVertices: function mergeVertices(geometry) {\n    var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    tolerance = Math.max(tolerance, Number.EPSILON);\n\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute('position');\n    var vertexCount = indices ? indices.count : positions.count;\n\n    // next value for triangle indices\n    var nextIndex = 0;\n\n    // attributes and new attribute arrays\n    var attributeNames = Object.keys(geometry.attributes);\n    var attrArrays = {};\n    var morphAttrsArrays = {};\n    var newIndices = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n\n    // initialize the arrays\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      attrArrays[name] = [];\n      var morphAttr = geometry.morphAttributes[name];\n      if (morphAttr) {\n        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(function () {\n          return [];\n        });\n      }\n    }\n\n    // convert the error tolerance to an amount of decimal places to truncate to\n    var decimalShift = Math.log10(1 / tolerance);\n    var shiftMultiplier = Math.pow(10, decimalShift);\n    for (var i = 0; i < vertexCount; i++) {\n      var index = indices ? indices.getX(i) : i;\n\n      // Generate a hash for the vertex attributes at the current index 'i'\n      var hash = '';\n      for (var j = 0, l = attributeNames.length; j < l; j++) {\n        var name = attributeNames[j];\n        var attribute = geometry.getAttribute(name);\n        var itemSize = attribute.itemSize;\n        for (var k = 0; k < itemSize; k++) {\n          // double tilde truncates the decimal value\n          hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n        }\n      }\n\n      // Add another reference to the vertex if it's already\n      // used by another index\n      if (hash in hashToIndex) {\n        newIndices.push(hashToIndex[hash]);\n      } else {\n        // copy data to the new index in the attribute arrays\n        for (var j = 0, l = attributeNames.length; j < l; j++) {\n          var name = attributeNames[j];\n          var attribute = geometry.getAttribute(name);\n          var morphAttr = geometry.morphAttributes[name];\n          var itemSize = attribute.itemSize;\n          var newarray = attrArrays[name];\n          var newMorphArrays = morphAttrsArrays[name];\n          for (var k = 0; k < itemSize; k++) {\n            var getterFunc = getters[k];\n            newarray.push(attribute[getterFunc](index));\n            if (morphAttr) {\n              for (var m = 0, ml = morphAttr.length; m < ml; m++) {\n                newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n              }\n            }\n          }\n        }\n        hashToIndex[hash] = nextIndex;\n        newIndices.push(nextIndex);\n        nextIndex++;\n      }\n    }\n\n    // Generate typed arrays from new attribute arrays and update\n    // the attributeBuffers\n    var result = geometry.clone();\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      var oldAttribute = geometry.getAttribute(name);\n      var buffer = new oldAttribute.array.constructor(attrArrays[name]);\n      var attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n      result.setAttribute(name, attribute);\n\n      // Update the attribute arrays\n      if (name in morphAttrsArrays) {\n        for (var j = 0; j < morphAttrsArrays[name].length; j++) {\n          var oldMorphAttribute = geometry.morphAttributes[name][j];\n          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n          var morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n          result.morphAttributes[name][j] = morphAttribute;\n        }\n      }\n    }\n\n    // indices\n\n    result.setIndex(newIndices);\n    return result;\n  },\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} drawMode\n   * @return {BufferGeometry>}\n   */\n  toTrianglesDrawMode: function toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === TrianglesDrawMode) {\n      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n      return geometry;\n    }\n    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n      var index = geometry.getIndex();\n\n      // generate index if not present\n\n      if (index === null) {\n        var indices = [];\n        var position = geometry.getAttribute('position');\n        if (position !== undefined) {\n          for (var i = 0; i < position.count; i++) {\n            indices.push(i);\n          }\n          geometry.setIndex(indices);\n          index = geometry.getIndex();\n        } else {\n          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n          return geometry;\n        }\n      }\n\n      //\n\n      var numberOfTriangles = index.count - 2;\n      var newIndices = [];\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (var i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (var i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n      if (newIndices.length / 3 !== numberOfTriangles) {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n      }\n\n      // build final geometry\n\n      var newGeometry = geometry.clone();\n      newGeometry.setIndex(newIndices);\n      newGeometry.clearGroups();\n      return newGeometry;\n    } else {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n      return geometry;\n    }\n  },\n  /**\n   * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n   * Helpful for Raytracing or Decals.\n   * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n   * @return {Object} An Object with original position/normal attributes and morphed ones.\n   */\n  computeMorphedAttributes: function computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n      console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n      return null;\n    }\n    var _vA = new Vector3();\n    var _vB = new Vector3();\n    var _vC = new Vector3();\n    var _tempA = new Vector3();\n    var _tempB = new Vector3();\n    var _tempC = new Vector3();\n    var _morphA = new Vector3();\n    var _morphB = new Vector3();\n    var _morphC = new Vector3();\n    function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n      _vA.fromBufferAttribute(attribute, a);\n      _vB.fromBufferAttribute(attribute, b);\n      _vC.fromBufferAttribute(attribute, c);\n      var morphInfluences = object.morphTargetInfluences;\n      if (material.morphTargets && morphAttribute && morphInfluences) {\n        _morphA.set(0, 0, 0);\n        _morphB.set(0, 0, 0);\n        _morphC.set(0, 0, 0);\n        for (var i = 0, il = morphAttribute.length; i < il; i++) {\n          var influence = morphInfluences[i];\n          var morphAttribute = morphAttribute[i];\n          if (influence === 0) continue;\n          _tempA.fromBufferAttribute(morphAttribute, a);\n          _tempB.fromBufferAttribute(morphAttribute, b);\n          _tempC.fromBufferAttribute(morphAttribute, c);\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n            _morphB.addScaledVector(_tempB, influence);\n            _morphC.addScaledVector(_tempC, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(_vA), influence);\n            _morphB.addScaledVector(_tempB.sub(_vB), influence);\n            _morphC.addScaledVector(_tempC.sub(_vC), influence);\n          }\n        }\n        _vA.add(_morphA);\n        _vB.add(_morphB);\n        _vC.add(_morphC);\n      }\n      if (object.isSkinnedMesh) {\n        object.boneTransform(a, _vA);\n        object.boneTransform(b, _vB);\n        object.boneTransform(c, _vC);\n      }\n      modifiedAttributeArray[a * 3 + 0] = _vA.x;\n      modifiedAttributeArray[a * 3 + 1] = _vA.y;\n      modifiedAttributeArray[a * 3 + 2] = _vA.z;\n      modifiedAttributeArray[b * 3 + 0] = _vB.x;\n      modifiedAttributeArray[b * 3 + 1] = _vB.y;\n      modifiedAttributeArray[b * 3 + 2] = _vB.z;\n      modifiedAttributeArray[c * 3 + 0] = _vC.x;\n      modifiedAttributeArray[c * 3 + 1] = _vC.y;\n      modifiedAttributeArray[c * 3 + 2] = _vC.z;\n    }\n    var geometry = object.geometry;\n    var material = object.material;\n    var a, b, c;\n    var index = geometry.index;\n    var positionAttribute = geometry.attributes.position;\n    var morphPosition = geometry.morphAttributes.position;\n    var morphTargetsRelative = geometry.morphTargetsRelative;\n    var normalAttribute = geometry.attributes.normal;\n    var morphNormal = geometry.morphAttributes.position;\n    var groups = geometry.groups;\n    var drawRange = geometry.drawRange;\n    var i, j, il, jl;\n    var group, groupMaterial;\n    var start, end;\n    var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n      // indexed buffer geometry\n\n      if (Array.isArray(material)) {\n        for (i = 0, il = groups.length; i < il; i++) {\n          group = groups[i];\n          groupMaterial = material[group.materialIndex];\n          start = Math.max(group.start, drawRange.start);\n          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n          for (j = start, jl = end; j < jl; j += 3) {\n            a = index.getX(j);\n            b = index.getX(j + 1);\n            c = index.getX(j + 2);\n            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n          }\n        }\n      } else {\n        start = Math.max(0, drawRange.start);\n        end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (i = start, il = end; i < il; i += 3) {\n          a = index.getX(i);\n          b = index.getX(i + 1);\n          c = index.getX(i + 2);\n          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else if (positionAttribute !== undefined) {\n      // non-indexed buffer geometry\n\n      if (Array.isArray(material)) {\n        for (i = 0, il = groups.length; i < il; i++) {\n          group = groups[i];\n          groupMaterial = material[group.materialIndex];\n          start = Math.max(group.start, drawRange.start);\n          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n          for (j = start, jl = end; j < jl; j += 3) {\n            a = j;\n            b = j + 1;\n            c = j + 2;\n            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n          }\n        }\n      } else {\n        start = Math.max(0, drawRange.start);\n        end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n        for (i = start, il = end; i < il; i += 3) {\n          a = i;\n          b = i + 1;\n          c = i + 2;\n          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    }\n    var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n    var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n    return {\n      positionAttribute: positionAttribute,\n      normalAttribute: normalAttribute,\n      morphedPositionAttribute: morphedPositionAttribute,\n      morphedNormalAttribute: morphedNormalAttribute\n    };\n  }\n};\nexport { BufferGeometryUtils };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","BufferGeometryUtils","computeTangents","geometry","console","warn","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","i","length","attributesCount","error","name","has","undefined","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","array","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","c","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","arguments","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","concat","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","material","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","il","influence","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute"],"sources":["/Users/markmathe/Downloads/Mysticus3DWebGame/app/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3\n} from '../../../build/three.module.js';\n\nvar BufferGeometryUtils = {\n\n\tcomputeTangents: function ( geometry ) {\n\n\t\tgeometry.computeTangents();\n\t\tconsole.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.' );\n\n\t},\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tvar attributes = {};\n\t\tvar morphAttributes = {};\n\n\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tvar mergedGeometry = new BufferGeometry();\n\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tvar geometry = geometries[ i ];\n\t\t\tvar attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tvar count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tvar indexOffset = 0;\n\t\t\tvar mergedIndex = [];\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tmergeBufferAttributes: function ( attributes ) {\n\n\t\tvar TypedArray;\n\t\tvar itemSize;\n\t\tvar normalized;\n\t\tvar arrayLength = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tvar array = new TypedArray( arrayLength );\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tinterleaveAttributes: function ( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tvar TypedArray;\n\t\tvar arrayLength = 0;\n\t\tvar stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tvar interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tvar offset = 0;\n\t\tvar res = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tvar attribute = attributes[ j ];\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar count = attribute.count;\n\t\t\tvar iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\testimateBytesUsed: function ( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tvar mem = 0;\n\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tvar indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tvar hashToIndex = {};\n\t\tvar indices = geometry.getIndex();\n\t\tvar positions = geometry.getAttribute( 'position' );\n\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tvar nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\tvar attrArrays = {};\n\t\tvar morphAttrsArrays = {};\n\t\tvar newIndices = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tvar hash = '';\n\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tvar attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tvar morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n\t * Helpful for Raytracing or Decals.\n\t * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n\t * @return {Object} An Object with original position/normal attributes and morphed ones.\n\t */\n\tcomputeMorphedAttributes: function ( object ) {\n\n\t\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar _vA = new Vector3();\n\t\tvar _vB = new Vector3();\n\t\tvar _vC = new Vector3();\n\n\t\tvar _tempA = new Vector3();\n\t\tvar _tempB = new Vector3();\n\t\tvar _tempC = new Vector3();\n\n\t\tvar _morphA = new Vector3();\n\t\tvar _morphB = new Vector3();\n\t\tvar _morphC = new Vector3();\n\n\t\tfunction _calculateMorphedAttributeData(\n\t\t\tobject,\n\t\t\tmaterial,\n\t\t\tattribute,\n\t\t\tmorphAttribute,\n\t\t\tmorphTargetsRelative,\n\t\t\ta,\n\t\t\tb,\n\t\t\tc,\n\t\t\tmodifiedAttributeArray\n\t\t) {\n\n\t\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\t\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar influence = morphInfluences[ i ];\n\t\t\t\t\tvar morphAttribute = morphAttribute[ i ];\n\n\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_vA.add( _morphA );\n\t\t\t\t_vB.add( _morphB );\n\t\t\t\t_vC.add( _morphC );\n\n\t\t\t}\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tobject.boneTransform( a, _vA );\n\t\t\t\tobject.boneTransform( b, _vB );\n\t\t\t\tobject.boneTransform( c, _vC );\n\n\t\t\t}\n\n\t\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t\t}\n\n\t\tvar geometry = object.geometry;\n\t\tvar material = object.material;\n\n\t\tvar a, b, c;\n\t\tvar index = geometry.index;\n\t\tvar positionAttribute = geometry.attributes.position;\n\t\tvar morphPosition = geometry.morphAttributes.position;\n\t\tvar morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tvar normalAttribute = geometry.attributes.normal;\n\t\tvar morphNormal = geometry.morphAttributes.position;\n\n\t\tvar groups = geometry.groups;\n\t\tvar drawRange = geometry.drawRange;\n\t\tvar i, j, il, jl;\n\t\tvar group, groupMaterial;\n\t\tvar start, end;\n\n\t\tvar modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\t\tvar modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( positionAttribute !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = j;\n\t\t\t\t\t\tb = j + 1;\n\t\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = i;\n\t\t\t\t\tb = i + 1;\n\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\t\tvar morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\t\treturn {\n\n\t\t\tpositionAttribute: positionAttribute,\n\t\t\tnormalAttribute: normalAttribute,\n\t\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t\t};\n\n\t}\n\n};\n\nexport { BufferGeometryUtils };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}